/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "stm32f746xx.h"

SPI_Handle_t SPI1Handle;

#define MAX_LEN 500

char RcvBuff[MAX_LEN];

volatile char ReadByte;


volatile uint8_t rcvStop = 0;

/*This flag will be set in the interrupt handler of the Arduino interrupt GPIO */
volatile uint8_t dataAvailable = 0;

/** SPI1 Pins  ALT5
 * PA4 --->NSS
 * PA5--->SCK
 * PA6--->MISO
 * PA7--->MOSI
 */
void I2C_GpioInit();
void I2C1_Inits();


I2C_Handle_t I2C1Handle;

#define MY_ADDR 0x61;

#define SLAVE_ADDR  0x68

uint8_t rcv_buf[32];

void Delay() {
    for (uint32_t i = 0; i < 500000/2; i++) {
        // Simple delay loop
    }
}

int main(void) {

    uint8_t commandcode;

	uint8_t len;

    // Initialize the GPIO pins for I2C
    I2C_GpioInit();

    // Initialize I2C1 peripheral
    I2C1_Inits();

    // Enable the I2C1 peripheral
    I2C_PeripheralControl(I2C1, ENABLE);

    commandcode = 0x51;

    I2C_MasterSendData(&I2C1Handle,&commandcode,1,SLAVE_ADDR,I2C_ENABLE_SR);

    I2C_MasterReceiveData(&I2C1Handle,&len,1,SLAVE_ADDR,I2C_ENABLE_SR);

    commandcode = 0x52;
    I2C_MasterSendData(&I2C1Handle,&commandcode,1,SLAVE_ADDR,I2C_ENABLE_SR);


    I2C_MasterReceiveData(&I2C1Handle,rcv_buf,len,SLAVE_ADDR,I2C_DISABLE_SR);

	rcv_buf[len+1] = '\0';

    printf("Data received from slave: %s\n", rcv_buf);

    while (1) {

    }

}

void I2C_GpioInit() {
    // Enable GPIOB clock first
    GPIOB_PCLK_EN();
    
    GPIO_Handle_t I2CPins = {0};

    I2CPins.pGPIOx = GPIOB;
    I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALT;
    I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4; // AF4 for I2C1
    I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD; // Open-drain
    I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // Pull-up
    I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

    // Configure PB8 (SCL)
    I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_8;
    GPIO_Init(&I2CPins);

    // Configure PB9 (SDA)
    I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_9;
    GPIO_Init(&I2CPins);
}

void I2C1_Inits() {



    I2C1Handle.pI2Cx = I2C1; // Use I2C1 peripheral
    I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_SPEED_SM; // Set SCL speed to Standard Mode
    I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR; // Set device address (example)
    I2C1Handle.I2C_Config.I2C_ACKControl = I2C_ACK_ENABLE; // Enable ACK
    I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2; // Set Fast Mode Duty Cycle
    I2C_Init(&I2C1Handle); // Initialize I2C1 with the configured settings

}



